<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Why Lucene never stores document IDs the way you think</title>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"></noscript>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){ dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'G-RP3XSZXCG2');
    </script>
    
<link rel="stylesheet" href="/blogs/css/content.css" />

</head>
<body>

<nav class="navbar is-transparent">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item is-size-3 has-text-weight-bold" href="/">Rahul Arora</a>
            <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navMenu">
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
            </a>
        </div>
        <div id="navMenu" class="navbar-menu">
            <div class="navbar-end">
                <a class="navbar-item is-size-5" href="/blogs/index.html">Blogs</a>
                <a class="navbar-item is-size-5" href="/reads/index.html">Reads</a>
            </div>
        </div>
    </div>
</nav>


<section class="section">
    <div class="container content">
        <h1 class="title is-3 mb-2">Why Lucene never stores document IDs the way you think</h1>

        
        <div class="tags is-justify-content-start mb-0">
            
            <span class="tag has-background-light has-text-dark">lucene</span>
            
        </div>
        

        
        <p class="has-text-grey is-size-6 mt-0 mb-4">5 min read</p>
        

        

        <p>I was recently going through Lucene’s internals, and one detail caught my attention: posting lists aren’t stored as plain arrays. Instead, Lucene uses <strong>delta encoding</strong>, which is a compression technique that drastically reduces space without losing information.</p>
<p>This optimization might seem small, but at a search engine scale, where millions of terms map to billions of postings, it makes a massive difference.</p>
<p>And the best part? The same principle is useful in many other systems too.</p>
<p>Let’s break it down step by step</p>
<hr />
<h2>Inverted index (a quick refresher)</h2>
<p>At the core of Lucene is the inverted index. Think of it as a giant lookup table:</p>
<ul>
<li>On the left: terms (words or tokens).</li>
<li>On the right: postings (information about which documents contain the term).</li>
</ul>
<p>For example, given two documents:</p>
<pre class="codehilite"><code>{ &quot;text&quot;: &quot;hello world&quot; }  // Doc 1  
{ &quot;text&quot;: &quot;hello lucene&quot; } // Doc 2
</code></pre>

<p>The inverted index would look like:</p>
<p><img alt="" src="/blogs/lucene-postings-list-compression/1.png" /></p>
<p>Each list of document IDs is called a postings list. In this toy example, lists are tiny. But in a large corpus, common terms might appear in millions of documents, so the <strong>postings list</strong> can become enormous, and hence compressing them is critical.</p>
<p>Let’s see in the next section how Lucene actually compresses the postings list.</p>
<hr />
<h2>Delta encoding (the key idea)</h2>
<p>Instead of storing raw document IDs, Lucene stores <strong>gaps (deltas)</strong> between them.</p>
<p><strong>Original list</strong></p>
<p>Take this example postings list:</p>
<p><img alt="" src="/blogs/lucene-postings-list-compression/2.png" /></p>
<p>Here, the size of an int (in Java) is 4 bytes, and for 4 values, we will need 16 bytes.</p>
<p><strong>Delta encoded list</strong></p>
<p>We take the first element as a reference point, and for every following element, we record the difference from the one before it. Applying this to our example gives us something like:</p>
<p><img alt="" src="/blogs/lucene-postings-list-compression/3.png" /></p>
<p><strong>Blocking for efficiency</strong></p>
<p>Lucene doesn’t compress the entire list at once. Instead, it splits it into fixed-size blocks (called PackedDocDeltaBlock in Lucene). In this example, let’s consider the block size is 2 values per block. This will look like:</p>
<p><img alt="" src="/blogs/lucene-postings-list-compression/4.png" /></p>
<p>Now, for each block, Lucene:</p>
<ul>
<li>Finds the maximum value.</li>
<li>Determines the minimum number of bits needed.</li>
<li>Stores the values tightly packed together using just those bits.</li>
</ul>
<p>The block header stores metadata (such as the number of bits required per number in a single byte) so that the decoder can reconstruct the list later. You could refer to the image given below to understand this better:</p>
<p><img alt="" src="/blogs/lucene-postings-list-compression/5.png" /></p>
<p>This reduces the original 16 bytes to around <strong>5 bytes (7 bits * 2 + 4 bits * 2 = 22 bits = 2.75 bytes + 1 byte in each block for the header = 5 bytes)</strong> in this example, which is a huge saving at scale.</p>
<p>The final step is storing values in a <strong>packed integer structure</strong>. This means values are laid out directly at the bit level, back to back, without wasting unused bits.</p>
<p>For instance, two numbers:</p>
<ul>
<li>8 → needs 4 bits</li>
<li>16 → needs 5 bits</li>
</ul>
<p>Together, they take just 9 bits. Instead of wasting a whole 32-bit integer for each, Lucene packs them efficiently into a continuous bit array (within a single int).</p>
<p>This technique is widely used beyond Lucene too. <a href="/blogs/roaring-bitmap">Roaring Bitmaps</a> or <a href="/blogs/java-bit-set">Java’s Bitset</a> are two very good examples of the same, which I’ve covered in earlier posts. Read these articles to get a better understanding of bit packing.</p>
<p>The entire process is described in the following diagram for a quick overview:</p>
<p><img alt="" src="/blogs/lucene-postings-list-compression/6.png" /></p>
<hr />
<h2>Ending notes</h2>
<p>In this article, we saw how Lucene compresses data to prevent wastage of space, and it’s a reminder of the engineering brilliance behind search libraries: powerful abstractions on the outside, and incredibly efficient low-level optimizations underneath.</p>
<p>Thank you for reading. I hope you learned something new today.</p>
<p>References:</p>
<p><a href="https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a><br />
<a href="https://lucene.apache.org/core/8_8_1/core/org/apache/lucene/codecs/lucene84/Lucene84PostingsFormat.html">https://lucene.apache.org/core/8_8_1/core/org/apache/lucene/codecs/lucene84/Lucene84PostingsFormat.html</a><br /></p>
<p>Happy coding!</p>
    </div>
</section>


<script>
    document.addEventListener('DOMContentLoaded', () => {
      const $burger = document.querySelector('.navbar-burger');
      const $menu = document.querySelector('#navMenu');
      $burger.addEventListener('click', () => {
        $burger.classList.toggle('is-active');
        $menu.classList.toggle('is-active');
      });
    });
  </script>
</body>
</html>